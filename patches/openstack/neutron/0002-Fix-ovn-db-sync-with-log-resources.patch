From 173cdb44735072d2aac9f37e28a5cad28c4453e0 Mon Sep 17 00:00:00 2001
From: ricolin <rlin@vexxhost.com>
Date: Thu, 12 Jun 2025 14:04:28 +0800
Subject: [PATCH] [stable/2024.2]Fix ovn db sync with log resources

Make sure neutron ovn db sync counts log resource changes.
This help to avoid important acls (like acls for `neutron_pg_drop`)
got deleted due to miss match case.

Additionally, switch to update instead of recreate acl in ovn sync.
To update optional columns, `pg-acl-add` could in some cases,
not able to properly update label and options columns.
With change to using db_set, we will sure we not face that same issue
in any cases.

Cherry-Pick from https://review.opendev.org/c/openstack/neutron/+/948053
Closes-Bug: #2107925
Closes-Bug: #2087909

Change-Id: I1da061ebd5bdf5cfee02ab6e0bdc393fa0762b8f
---
 neutron/common/ovn/acl.py                     |   6 +-
 neutron/common/ovn/constants.py               |   3 +-
 .../ovn/mech_driver/ovsdb/ovn_db_sync.py      | 258 +++++++++++++++++-
 3 files changed, 252 insertions(+), 15 deletions(-)

diff --git a/neutron/common/ovn/acl.py b/neutron/common/ovn/acl.py
index 2a65ff73fa..a12a931968 100644
--- a/neutron/common/ovn/acl.py
+++ b/neutron/common/ovn/acl.py
@@ -148,7 +148,9 @@ def add_acls_for_drop_port_group(pg_name):
                "name": [],
                "severity": [],
                "direction": direction,
-               "match": '%s == @%s && ip' % (p, pg_name)}
+               "match": '%s == @%s && ip' % (p, pg_name),
+               "meter": [],
+               }
         acl_list.append(acl)
     return acl_list
 
@@ -167,6 +169,7 @@ def drop_all_ip_traffic_for_port(port):
                "severity": [],
                "direction": direction,
                "match": '%s == "%s" && ip' % (p, port['id']),
+               "meter": [],
                "external_ids": {'neutron:lport': port['id']}}
         acl_list.append(acl)
     return acl_list
@@ -187,6 +190,7 @@ def add_sg_rule_acl_for_port_group(port_group, r, stateful, match):
            "severity": [],
            "direction": dir_map[r['direction']],
            "match": match,
+           "meter": [],
            ovn_const.OVN_SG_RULE_EXT_ID_KEY: r['id']}
     return acl
 
diff --git a/neutron/common/ovn/constants.py b/neutron/common/ovn/constants.py
index 700f7468ab..d5f0257c57 100644
--- a/neutron/common/ovn/constants.py
+++ b/neutron/common/ovn/constants.py
@@ -260,7 +260,8 @@ INITIAL_REV_NUM = -1
 
 ACL_EXPECTED_COLUMNS_NBDB = (
     'external_ids', 'direction', 'log', 'priority',
-    'name', 'action', 'severity', 'match')
+    'name', 'action', 'severity', 'match', 'meter',
+    'label', 'options')
 
 # Resource types
 TYPE_NETWORKS = 'networks'
diff --git a/neutron/plugins/ml2/drivers/ovn/mech_driver/ovsdb/ovn_db_sync.py b/neutron/plugins/ml2/drivers/ovn/mech_driver/ovsdb/ovn_db_sync.py
index e945c1e629..6928a3528a 100644
--- a/neutron/plugins/ml2/drivers/ovn/mech_driver/ovsdb/ovn_db_sync.py
+++ b/neutron/plugins/ml2/drivers/ovn/mech_driver/ovsdb/ovn_db_sync.py
@@ -13,6 +13,7 @@
 import abc
 from datetime import datetime
 import itertools
+import secrets
 
 from eventlet import greenthread
 from neutron_lib.api.definitions import segment as segment_def
@@ -35,6 +36,8 @@ from neutron.objects.port_forwarding import PortForwarding
 from neutron.plugins.ml2.drivers.ovn.mech_driver.ovsdb.extensions import qos \
     as ovn_qos
 from neutron.plugins.ml2.drivers.ovn.mech_driver.ovsdb import ovn_client
+from neutron.services.logapi.common import db_api as log_db_api
+from neutron.services.logapi.drivers.ovn import driver as log_driver
 from neutron.services.segments import db as segments_db
 
 
@@ -86,6 +89,7 @@ class OvnNbSynchronizer(OvnDbSynchronizer):
             self.segments_plugin = (
                 manager.NeutronManager.load_class_for_provider(
                     'neutron.service_plugins', 'segments')())
+        self.ovn_log_driver = log_driver.OVNDriver()
 
     def stop(self):
         if utils.is_ovn_l3(self.l3_plugin):
@@ -245,6 +249,7 @@ class OvnNbSynchronizer(OvnDbSynchronizer):
             for acl in acls:
                 acl_string = {k: getattr(acl, k) for k in acl_columns}
                 acl_string['port_group'] = pg.name
+                acl_string['uuid'] = acl.uuid
                 if id_key in acl.external_ids:
                     acl_string[id_key] = acl.external_ids[id_key]
                 ovn_acls.append(acl_string)
@@ -258,16 +263,66 @@ class OvnNbSynchronizer(OvnDbSynchronizer):
         @return: Nothing
         """
         LOG.debug('OVN-NB Sync ACLs started @ %s', str(datetime.now()))
-
+        sg_log_map = {}
+        sgr_sg_map = {}
         neutron_acls = []
+        acl_meter_name = self.ovn_log_driver.meter_name
+        acl_options = {'log-related': "true"}
+        is_support_label = "label" in (
+            self.ovn_api._tables['ACL'].columns.keys() &
+            set(ovn_const.ACL_EXPECTED_COLUMNS_NBDB)
+        )
+
+        def _fetch_log_attrs(n_id, na):
+            # Check if logs exist for sg, if exist,
+            # will try to compare with log info
+            if len(sg_log_map.get(sgr_sg_map.get(n_id, None)[0], {})) > 0:
+                # get logs for security group
+                sg_logs = sg_log_map.get(sgr_sg_map.get(n_id)[0])
+                # No oa matched, directly assign one log
+                acl_name, sg_log = next(iter(sg_logs.items()))
+
+                # check stateful for security group
+                if not sgr_sg_map.get(n_id)[1]:
+                    meter_name = acl_meter_name + ("_stateless")
+                else:
+                    meter_name = acl_meter_name
+                actions_enabled = self.ovn_log_driver._acl_actions_enabled(
+                    sg_log)
+                log_attrs = {
+                    "log": na.get("action") in actions_enabled,
+                    "meter": [meter_name],
+                    "severity": ["info"],
+                    "name": [acl_name]
+                }
+                if is_support_label:
+                    # Label needs to be an unsigned 32 bit number
+                    # and not 0.
+                    log_attrs['label'] = secrets.SystemRandom(
+                    ).randrange(1, log_driver.MAX_INT_LABEL)
+                    log_attrs['options'] = acl_options
+            else:
+                log_attrs = {"label": 0, "options": {}} if (
+                    is_support_label) else {}
+            return log_attrs
+
         # if allow-stateless supported, we have to fetch groups to determine if
         # stateful is set
         if self._ovn_client.is_allow_stateless_supported():
             for sg in self.core_plugin.get_security_groups(ctx):
                 stateful = sg.get("stateful", True)
                 pg_name = utils.ovn_port_group_name(sg['id'])
+
+                # Fetch logs for security group
+                sg_logs = log_db_api.get_logs_bound_sg(ctx, sg_id=sg['id'])
+                if sg_logs:
+                    sg_log_map[sg['id']] = {
+                        (f"{ovn_const.OVN_NAME_PREFIX}"
+                         f"{sg_log.id}"): sg_log for sg_log in sg_logs
+                    }
                 for sgr in self.core_plugin.get_security_group_rules(
                         ctx, {'security_group_id': sg['id']}):
+                    sgr_sg_map[sgr['id']] = (sg['id'], stateful)
                     neutron_acls.append(
                         acl_utils._add_sg_rule_acl_for_port_group(
                             pg_name, stateful, sgr)
@@ -290,7 +345,7 @@ class OvnNbSynchronizer(OvnDbSynchronizer):
         ovn_acls.sort(key=lambda x: x.get(
             ovn_const.OVN_SG_RULE_EXT_ID_KEY, ""))
         neutron_num, ovn_num = len(neutron_acls), len(ovn_acls)
-        add_acls, remove_acls, ovn_default_acls = [], [], []
+        add_acls, remove_acls, ovn_default_acls, update_acls = [], [], [], []
         n_index = o_index = 0
         # neutron_acls and ovn_acls have been sorted, and we need to traverse
         # both arrays from scratch until we reach the end of one of them.
@@ -313,22 +368,76 @@ class OvnNbSynchronizer(OvnDbSynchronizer):
                 ovn_default_acls.append(oa)
                 o_index += 1
             elif n_id == o_id:
+                # Check if logs exist for sg, if exist,
+                # will try to compare with log info
+                if len(sg_log_map.get(sgr_sg_map.get(n_id, None)[0], {})) > 0:
+                    # get logs for security group
+                    sg_logs = sg_log_map.get(sgr_sg_map.get(n_id)[0])
+
+                    # Determine one log for acl
+                    oa_name = next(iter(oa.get("name")), None)
+                    if oa_name and oa_name in sg_logs:
+                        sg_log = sg_logs.get(oa_name)
+                        acl_name = oa_name
+                    else:
+                        acl_name, sg_log = next(iter(sg_logs.items()))
+
+                    # check stateful for security group
+                    if not sgr_sg_map.get(n_id)[1]:
+                        meter_name = acl_meter_name + ("_stateless")
+                    else:
+                        meter_name = acl_meter_name
+                    actions_enabled = self.ovn_log_driver._acl_actions_enabled(
+                        sg_log)
+                    log_attrs = {
+                        "log": na.get("action") in actions_enabled,
+                        "meter": [meter_name],
+                        "severity": ["info"],
+                        "name": [acl_name]
+                    }
+
+                    oa_label = oa.get("label", None)
+                    # if label in OVN acl not found,
+                    # that means OVN version < 22.03
+                    if oa_label is not None:
+                        # Label needs to be an unsigned 32 bit number
+                        # and not 0.
+                        if log_driver.MAX_INT_LABEL >= oa_label > 0:
+                            # Try to reuse existing label to avoid unnecessary
+                            # acl update
+                            log_attrs['label'] = oa_label
+                        else:
+                            log_attrs['label'] = secrets.SystemRandom(
+                            ).randrange(1, log_driver.MAX_INT_LABEL)
+                        log_attrs['options'] = acl_options
+                else:
+                    log_attrs = {"label": 0, "options": {}} if (
+                        is_support_label) else {}
+
+                # allow reuse existing acl
+                na['uuid'] = oa.get('uuid')
+                # Update neutron acl with log related attributes
+                na.update(log_attrs)
                 if any(item not in na.items() for item in oa.items()):
-                    add_acls.append(na)
-                    remove_acls.append(oa)
+                    update_acls.append(na)
                 n_index += 1
                 o_index += 1
             elif n_id > o_id:
                 remove_acls.append(oa)
                 o_index += 1
             else:
+                # Update neutron acl with log related attributes
+                na.update(_fetch_log_attrs(n_id, na))
                 add_acls.append(na)
                 n_index += 1
 
         if n_index < neutron_num:
             # We didn't find the OVN ACLs matching the Neutron ACLs
             # in "ovn_acls" and we are just adding the pending Neutron ACLs.
-            add_acls.extend(neutron_acls[n_index:])
+            for na in neutron_acls[n_index:]:
+                n_id = na[ovn_const.OVN_SG_RULE_EXT_ID_KEY]
+                na.update(_fetch_log_attrs(n_id, na))
+                add_acls.append(na)
         if o_index < ovn_num:
             # Any OVN ACLs not matching the Neutron ACLs is removed.
             remove_acls.extend(ovn_acls[o_index:])
@@ -341,26 +450,118 @@ class OvnNbSynchronizer(OvnDbSynchronizer):
             self.ovn_api._tables['Logical_Switch'].rows.values())]
         num_acls_to_remove_from_ls = get_num_acls(ovn_acls_from_ls)
 
+        def _fetch_default_log_attrs(
+                acl_name, target_log, na_action, oa_label=None):
+            log_attrs = {"label": 0, "options": {}} if (
+                is_support_label) else {}
+            if target_log is None:
+                for logs in sg_log_map.values():
+                    for name, log_item in logs.items():
+                        if log_item.event.upper() == na_action.upper():
+                            acl_name, target_log = name, log_item
+                            break
+                    else:
+                        continue
+                    break
+
+            if target_log:
+                actions_enabled = (
+                    self.ovn_log_driver._acl_actions_enabled(
+                        target_log)
+                )
+                log_attrs = {
+                    "log": na_action in actions_enabled,
+                    "meter": [acl_meter_name],
+                    "severity": ["info"],
+                    "name": [acl_name or ""]
+                }
+                # if label in OVN acl not found,
+                # that means OVN version < 22.03
+                if oa_label is not None:
+                    # Label needs to be an unsigned 32 bit number
+                    # and not 0.
+                    if log_driver.MAX_INT_LABEL >= oa_label > 0:
+                        # Try to reuse existing label to avoid
+                        # unnecessary acl update
+                        log_attrs['label'] = oa_label
+                    else:
+                        log_attrs['label'] = secrets.SystemRandom(
+                        ).randrange(1, log_driver.MAX_INT_LABEL)
+                    log_attrs['options'] = acl_options
+            return log_attrs
+
         # Remove the common ones
         for na in list(neutron_default_acls):
             for ovn_a in ovn_default_acls.copy():
-                if all(item in na.items() for item in ovn_a.items()):
-                    neutron_default_acls.remove(na)
-                    ovn_default_acls.remove(ovn_a)
-                    break
+                basic_match = True
+                for col in ('direction', 'match', 'action'):
+                    if ovn_a.get(col) != na.get(col):
+                        basic_match = False
+                        continue
+                if not basic_match:
+                    continue
+                # We can drop this acl from lists. And may add
+                # to update_acls later if any part need to be update.
+                neutron_default_acls.remove(na)
+                ovn_default_acls.remove(ovn_a)
+
+                # At this point we can reuse ovn_a uuid for acl update
+                na['uuid'] = ovn_a.get('uuid')
+
+                # If no logs found for all security group,
+                # we can skip log fetch for default acls
+                if sg_log_map:
+                    # Fetch acl_name and target_log
+                    # Try to find match log if name is set.
+                    acl_name = next(iter(ovn_a.get("name")), None)
+                    target_log = None
+                    if acl_name:
+                        # check ovn acl name is valid
+                        for logs in sg_log_map.values():
+                            if acl_name in logs:
+                                target_log = logs.get(acl_name)
+                                break
+                    log_attrs = _fetch_default_log_attrs(
+                        acl_name,
+                        target_log,
+                        na_action=na.get("action"),
+                        oa_label=ovn_a.get("label", None)
+                    )
+                else:
+                    log_attrs = {"label": 0, "options": {}} if (
+                        is_support_label) else {}
+                # Update neutron acl with log related attributes
+                na.update(log_attrs)
+                if any(item not in na.items() for item in ovn_a.items()):
+                    # needs update this acl
+                    update_acls.append(na)
+        # Add logs attrs acls in neutron_default_acls
+        for nda in neutron_default_acls:
+            if sg_log_map:
+                log_attrs = _fetch_default_log_attrs(
+                    acl_name=None, target_log=None,
+                    na_action=nda.get("action"), oa_label=None)
+            else:
+                log_attrs = {"label": 0, "options": {}} if (
+                    is_support_label) else {}
+            nda.update(log_attrs)
         neutron_acls = add_acls + neutron_default_acls
         ovn_acls = remove_acls + ovn_default_acls
         num_acls_to_add = len(neutron_acls)
         num_acls_to_remove = len(ovn_acls) + num_acls_to_remove_from_ls
-        if num_acls_to_add or num_acls_to_remove:
+        num_acls_to_update = len(update_acls)
+        if num_acls_to_add or num_acls_to_remove or num_acls_to_update:
             LOG.warning('ACLs to be added: %(add)d '
-                        'ACLs to be removed: %(remove)d',
+                        'ACLs to be removed: %(remove)d '
+                        'ACLs to be update: %(update)d',
                         {'add': num_acls_to_add,
-                         'remove': num_acls_to_remove})
+                         'remove': num_acls_to_remove,
+                         'update': num_acls_to_update})
 
         if (self.mode == SYNC_MODE_REPAIR and
-                (num_acls_to_add or num_acls_to_remove)):
+                (num_acls_to_add or num_acls_to_remove or num_acls_to_update)):
             one_time_pg_resync = True
+            new_acl_update_list = []
             while True:
                 try:
                     with self.ovn_api.transaction(check_error=True) as txn:
@@ -368,6 +569,8 @@ class OvnNbSynchronizer(OvnDbSynchronizer):
                             LOG.warning('ACL found in Neutron but not in '
                                         'OVN NB DB for port group %s',
                                         acla['port_group'])
+                            if 'label' in acla and acla['label'] > 0:
+                                new_acl_update_list.append(acla)
                             txn.add(self.ovn_api.pg_acl_add(
                                 **acla, may_exist=True))
                 except idlutils.RowNotFound as row_err:
@@ -404,6 +607,35 @@ class OvnNbSynchronizer(OvnDbSynchronizer):
                                     'Switch %s', aclr[0])
                         txn.add(self.ovn_api.acl_del(aclr[0]))
 
+                for aclu in update_acls:
+                    acl_uuid = aclu.pop('uuid')
+                    aclu.pop('port_group', None)
+                    sgr_id = aclu.pop(ovn_const.OVN_SG_RULE_EXT_ID_KEY, None)
+                    if sgr_id:
+                        aclu['external_ids'] = aclu.get(
+                            'external_ids', {}
+                        ).update({ovn_const.OVN_SG_RULE_EXT_ID_KEY: sgr_id})
+
+                    txn.add(self.ovn_api.db_set(
+                        "ACL", acl_uuid, *aclu.items()))
+
+                # fetch uuid for new_acl_update_list so we can
+                # update it's options and label is required.
+                if is_support_label and new_acl_update_list:
+                    ovn_acls = self._get_acls_from_port_groups()
+                    for aclu in new_acl_update_list:
+                        n_id = aclu[ovn_const.OVN_SG_RULE_EXT_ID_KEY]
+                        for oa in ovn_acls:
+                            o_id = oa.get(ovn_const.OVN_SG_RULE_EXT_ID_KEY)
+                            if n_id == o_id:
+                                acl_uuid = oa.get('uuid')
+                                txn.add(self.ovn_api.db_set(
+                                    "ACL", acl_uuid,
+                                    ('label', aclu['label']),
+                                    ('options', aclu['options'])
+                                ))
+                                break
+
         LOG.debug('OVN-NB Sync ACLs completed @ %s', str(datetime.now()))
 
     def _calculate_routes_differences(self, ovn_routes, db_routes):
-- 
2.25.1

