diff --git a/ovn_bgp_agent/config.py b/ovn_bgp_agent/config.py
index 63a04f6..a43e8ab 100644
--- a/ovn_bgp_agent/config.py
+++ b/ovn_bgp_agent/config.py
@@ -66,6 +66,9 @@ agent_opts = [
                choices=('ovn_bgp_driver', 'ovn_evpn_driver',
                         'ovn_stretched_l2_bgp_driver', 'nb_ovn_bgp_driver'),
                default='ovn_bgp_driver'),
+    cfg.StrOpt('frr_driver',
+               help='FRR Driver to be used',
+               default='frr'),
     cfg.StrOpt('ovsdb_connection',
                default='unix:/usr/local/var/run/openvswitch/db.sock',
                help='The connection string for the native OVSDB backend.\n'
@@ -240,6 +243,102 @@ local_ovn_cluster_opts = [
                      ' NB driver is used.'),
 ]
 
+frr_k8s_opts = [
+    cfg.StrOpt('node_to_config',
+               help='Node to config.',
+               default=''),
+    cfg.StrOpt('namespace',
+               help='namespace to config frr_k8s',
+               default='frr-k8s-system'),
+    cfg.IntOpt('my_asn',
+               default=64999,
+               help='Local AS number to be used by the Agent when running '
+                    'in BGP mode and configuring the VRF route leaking.'),
+    cfg.ListOpt('prefixes',
+                help='Prefixes is the list of prefixes we want to advertise '
+                     'from the router instance.',
+                default=None),
+    cfg.StrOpt('vrf_name',
+               help='The host vrf used to establish sessions from the router.',
+               default=None),
+    cfg.StrOpt('router_id',
+               help='Router ID to be used by the Agent when running in BGP '
+                    'mode and configuring the VRF route leaking.',
+               default=None),
+    cfg.StrOpt('peer_address',
+               help='BGP peer IP address and port.',
+               default='10.2.2.254:179'),
+    cfg.StrOpt('source_address',
+               help='IPv4 or IPv6 source address to use for the BGP.',
+               default='10.1.1.254'),
+    cfg.IntOpt('peer_asn',
+               help='Peer AS number to be used by the Agent when running '
+                    'in BGP mode and configuring the VRF route leaking.',
+               default=64999),
+    cfg.StrOpt('dynamic_asn',
+               help='DynamicASN detects the AS number to use for the local '
+                    ' end of the session without explicitly setting it via '
+                    ' the ASN field.',
+               choices=('internal', 'external'),
+               default=None),
+    cfg.StrOpt('password',
+               help='Password to be used for establishing the BGP session.',
+               default=None),
+    cfg.StrOpt('password_secret',
+               help='Name of the authentication secret for the neighbor.',
+               default=None),
+    cfg.StrOpt('hold_time',
+               default='180s',
+               help='The requested BGP hold time.'),
+    cfg.StrOpt('keep_alive_time',
+               default='60s',
+               help='The requested BGP keepalive time.'),
+    cfg.StrOpt('connect_time',
+               default=None,
+               help='Requested BGP connect time, controls how long BGP waits '
+                    'between connection attempts to a neighbor.'),
+    cfg.BoolOpt('ebgp_multi_hop',
+                help='Indicates if the BGPPeer is multi-hops away.',
+                default=False),
+    cfg.StrOpt('bfd_profile',
+               default=None,
+               help='The name of the BFD Profile to be used for the BFD '
+                    'session associated.'),
+    cfg.BoolOpt('graceful_restart',
+                default=False,
+                help='Allows BGP peer to continue to forward data packets '
+                     'along known routes while the routing protocol '
+                     'information is being restored. If the session is '
+                     'already established, the configuration will have '
+                     'effect after reconnecting to the peer.'),
+    cfg.BoolOpt('disable_mp',
+                help='To set if we want to disable MP BGP that will '
+                     'separate IPv4 and IPv6 route exchanges into distinct '
+                     'BGP sessions.',
+                default=False),
+    cfg.ListOpt('to_advertise',
+                help='ToAdvertise represents the list of prefixes to '
+                     'advertise to the given neighbor and the associated '
+                     'properties.',
+                default=None),
+    cfg.ListOpt('to_receive',
+                help='ToReceive represents the list of prefixes to receive '
+                     'from the given neighbor.',
+                default=None),
+    cfg.ListOpt('local_pref',
+                help='list of prefixes that are associated to a local '
+                     'preference when being advertised. The prefixes '
+                     'associated to a given local pref must be in the '
+                     'prefixes allowed to be advertised.',
+                default=None),
+    cfg.ListOpt('communities',
+                help='list of prefixes that are associated to a bgp '
+                     'community when being advertised. The prefixes '
+                     'associated to a given bgp community must be in the '
+                     'prefixes allowed to be advertised.',
+                default=None),
+
+]
 CONF = cfg.CONF
 EXTRA_LOG_LEVEL_DEFAULTS = [
     'oslo.privsep.daemon=INFO'
@@ -253,6 +352,7 @@ def register_opts():
     CONF.register_opts(root_helper_opts, "agent")
     CONF.register_opts(ovn_opts, "ovn")
     CONF.register_opts(local_ovn_cluster_opts, "local_ovn_cluster")
+    CONF.register_opts(frr_k8s_opts, "frr_k8s")
 
 
 def init(args, **kwargs):
@@ -280,4 +380,5 @@ def list_opts():
         ("agent", root_helper_opts),
         ("ovn", ovn_opts),
         ("local_ovn_cluster", local_ovn_cluster_opts),
+        ("frr_k8s", frr_k8s_opts),
     ]
diff --git a/ovn_bgp_agent/drivers/frr_driver_api.py b/ovn_bgp_agent/drivers/frr_driver_api.py
new file mode 100644
index 0000000..47bf926
--- /dev/null
+++ b/ovn_bgp_agent/drivers/frr_driver_api.py
@@ -0,0 +1,44 @@
+# Copyright 2024 VEXXHOST, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import abc
+from stevedore import driver as stevedore_driver
+
+
+class FRRDriverBase(object, metaclass=abc.ABCMeta):
+    """Base class for FRR drivers.
+
+    """
+
+    @classmethod
+    def get_instance(cls, specific_driver):
+        frr_driver = stevedore_driver.DriverManager(
+            namespace='ovn_bgp_agent.drivers',
+            name=specific_driver,
+            invoke_on_load=True
+        ).driver
+
+        return frr_driver
+
+    @abc.abstractmethod
+    def nd_reconfigure(self, interface, prefix, opts):
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def vrf_leak(self, vrf, bgp_as, bgp_router_id=None):
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def vrf_reconfigure(self, evpn_info, action):
+        raise NotImplementedError()
diff --git a/ovn_bgp_agent/drivers/openstack/ovn_evpn_driver.py b/ovn_bgp_agent/drivers/openstack/ovn_evpn_driver.py
index 49cb2aa..fde73a9 100644
--- a/ovn_bgp_agent/drivers/openstack/ovn_evpn_driver.py
+++ b/ovn_bgp_agent/drivers/openstack/ovn_evpn_driver.py
@@ -22,7 +22,7 @@ from oslo_log import log as logging
 
 from ovn_bgp_agent import constants
 from ovn_bgp_agent.drivers import driver_api
-from ovn_bgp_agent.drivers.openstack.utils import frr
+from ovn_bgp_agent.drivers import frr_driver_api
 from ovn_bgp_agent.drivers.openstack.utils import ovn
 from ovn_bgp_agent.drivers.openstack.utils import ovs
 from ovn_bgp_agent.drivers.openstack.watchers import base_watcher
@@ -56,6 +56,9 @@ class OVNEVPNDriver(driver_api.AgentDriverBase):
         self._sb_idl = None
         self._post_fork_event = threading.Event()
 
+        self.frr_driver = frr_driver_api.FRRDriverBase.get_instance(
+            CONF.frr_driver)
+
     @property
     def sb_idl(self):
         if not self._sb_idl:
@@ -242,7 +245,7 @@ class OVNEVPNDriver(driver_api.AgentDriverBase):
             'vlan': evpn_devices.vlan_name
         }
 
-        frr.vrf_reconfigure(evpn_info, action="add-vrf")
+        self.frr_driver.vrf_reconfigure(evpn_info, action="add-vrf")
 
         self._connect_evpn_to_ovn(evpn_devices.vrf_name, evpn_devices.veth_vrf,
                                   evpn_devices.veth_ovs, ips, datapath_bridge,
@@ -326,7 +329,7 @@ class OVNEVPNDriver(driver_api.AgentDriverBase):
                                          cr_lrp_info.get('mac'))
 
         evpn_info = {'vni': evpn_vni, 'bgp_as': cr_lrp_info.get('bgp_as')}
-        frr.vrf_reconfigure(evpn_info, action="del-vrf")
+        self.frr_driver.vrf_reconfigure(evpn_info, action="del-vrf")
 
         try:
             del self.ovn_local_cr_lrps[cr_lrp_port_name]
diff --git a/ovn_bgp_agent/drivers/openstack/ovn_stretched_l2_bgp_driver.py b/ovn_bgp_agent/drivers/openstack/ovn_stretched_l2_bgp_driver.py
index 9eec639..6c76030 100644
--- a/ovn_bgp_agent/drivers/openstack/ovn_stretched_l2_bgp_driver.py
+++ b/ovn_bgp_agent/drivers/openstack/ovn_stretched_l2_bgp_driver.py
@@ -23,9 +23,9 @@ from oslo_log import log as logging
 
 from ovn_bgp_agent import constants
 from ovn_bgp_agent.drivers import driver_api
+from ovn_bgp_agent.drivers import frr_driver_api
 from ovn_bgp_agent.drivers.openstack.utils import bgp as bgp_utils
 from ovn_bgp_agent.drivers.openstack.utils import driver_utils
-from ovn_bgp_agent.drivers.openstack.utils import frr
 from ovn_bgp_agent.drivers.openstack.utils import ovn
 from ovn_bgp_agent.drivers.openstack.utils import ovs
 from ovn_bgp_agent.drivers.openstack.watchers import bgp_watcher as watcher
@@ -57,6 +57,9 @@ class OVNBGPStretchedL2Driver(driver_api.AgentDriverBase):
         self._sb_idl = None
         self._post_fork_event = threading.Event()
 
+        self.frr_driver = frr_driver_api.FRRDriverBase.get_instance(
+            CONF.frr_driver)
+
     @property
     def sb_idl(self):
         if not self._sb_idl:
@@ -73,7 +76,7 @@ class OVNBGPStretchedL2Driver(driver_api.AgentDriverBase):
 
         # Base BGP configuration
         # Ensure FRR is configured to leak only kernel routes by default
-        frr.set_default_redistribute(['kernel'])
+        self.frr_driver.set_default_redistribute(['kernel'])
         bgp_utils.ensure_base_bgp_configuration()
 
         # Clear vrf routing table
diff --git a/ovn_bgp_agent/drivers/openstack/utils/bgp.py b/ovn_bgp_agent/drivers/openstack/utils/bgp.py
index e4a388c..c10f2fd 100644
--- a/ovn_bgp_agent/drivers/openstack/utils/bgp.py
+++ b/ovn_bgp_agent/drivers/openstack/utils/bgp.py
@@ -16,6 +16,7 @@ from oslo_config import cfg
 from oslo_log import log as logging
 
 from ovn_bgp_agent import constants
+from ovn_bgp_agent.drivers import frr_driver_api
 from ovn_bgp_agent.drivers.openstack.utils import driver_utils
 from ovn_bgp_agent.drivers.openstack.utils import evpn
 from ovn_bgp_agent.drivers.openstack.utils import frr
@@ -73,16 +74,19 @@ def ensure_base_bgp_configuration(template=frr.LEAK_VRF_TEMPLATE):
                                     constants.EXPOSE_METHOD_OVN]:
         return
 
+    frr_driver = frr_driver_api.FRRDriverBase.get_instance(
+        CONF.frr_driver)
+
     # Create VRF
     linux_net.ensure_vrf(CONF.bgp_vrf, CONF.bgp_vrf_table_id)
 
     # If we expose subnet routes, we should add kernel routes too.
     if CONF.advertisement_method_tenant_networks == 'subnet':
-        frr.set_default_redistribute(['connected', 'kernel'])
+        frr_driver.set_default_redistribute(['connected', 'kernel'])
 
     # Ensure FRR is configure to leak the routes
-    frr.vrf_leak(CONF.bgp_vrf, CONF.bgp_AS, CONF.bgp_router_id,
-                 template=template)
+    frr_driver.vrf_leak(CONF.bgp_vrf, CONF.bgp_AS, CONF.bgp_router_id,
+                        template=template)
 
     # Create OVN dummy device
     linux_net.ensure_ovn_device(CONF.bgp_nic, CONF.bgp_vrf)
diff --git a/ovn_bgp_agent/drivers/openstack/utils/frr.py b/ovn_bgp_agent/drivers/openstack/utils/frr.py
index e35e4b9..214c7ae 100644
--- a/ovn_bgp_agent/drivers/openstack/utils/frr.py
+++ b/ovn_bgp_agent/drivers/openstack/utils/frr.py
@@ -20,6 +20,7 @@ from oslo_config import cfg
 from oslo_log import log as logging
 
 from ovn_bgp_agent import constants
+from ovn_bgp_agent.drivers import frr_driver_api
 import ovn_bgp_agent.privileged.vtysh
 
 CONF = cfg.CONF
@@ -113,111 +114,112 @@ router bgp {{ bgp_as }} vrf {{ vrf_name }}
 '''
 
 
-def _get_router_id():
-    output = ovn_bgp_agent.privileged.vtysh.run_vtysh_command(
-        command='show ip bgp summary json')
-    return json.loads(output).get('ipv4Unicast', {}).get('routerId')
-
-
-def _run_vtysh_config_with_tempfile(vrf_config):
-    try:
-        f = tempfile.NamedTemporaryFile(mode='w')
-        f.write(vrf_config)
-        f.flush()
-    except (IOError, OSError) as e:
-        LOG.error('Failed to create the VRF configuration '
-                  'file. Error: %s', e)
-        if f is not None:
-            f.close()
-        raise
-
-    try:
-        ovn_bgp_agent.privileged.vtysh.run_vtysh_config(f.name)
-    finally:
-        if f is not None:
-            f.close()
-
-
-def set_default_redistribute(redist_opts):
-    if not isinstance(redist_opts, set):
-        redist_opts = set(redist_opts)
+class FRRDriver(frr_driver_api.FRRDriverBase):
+
+    def _get_router_id(self):
+        output = ovn_bgp_agent.privileged.vtysh.run_vtysh_command(
+            command='show ip bgp summary json')
+        return json.loads(output).get('ipv4Unicast', {}).get('routerId')
+
+    def _run_vtysh_config_with_tempfile(self, vrf_config):
+        try:
+            f = tempfile.NamedTemporaryFile(mode='w')
+            f.write(vrf_config)
+            f.flush()
+        except (IOError, OSError) as e:
+            LOG.error('Failed to create the VRF configuration '
+                      'file. Error: %s', e)
+            if f is not None:
+                f.close()
+            raise
+
+        try:
+            ovn_bgp_agent.privileged.vtysh.run_vtysh_config(f.name)
+        finally:
+            if f is not None:
+                f.close()
+
+    def set_default_redistribute(self, redist_opts):
+        if not isinstance(redist_opts, set):
+            redist_opts = set(redist_opts)
+
+        if redist_opts == DEFAULT_REDISTRIBUTE:
+            # no update required.
+            return
 
-    if redist_opts == DEFAULT_REDISTRIBUTE:
-        # no update required.
-        return
+        DEFAULT_REDISTRIBUTE.clear()
+        DEFAULT_REDISTRIBUTE.update(redist_opts)
 
-    DEFAULT_REDISTRIBUTE.clear()
-    DEFAULT_REDISTRIBUTE.update(redist_opts)
+    def nd_reconfigure(self, interface, prefix, opts):
+        LOG.info('FRR IPv6 ND reconfiguration (intf %s, prefix %s)', interface,
+                 prefix)
+        nd_template = Template(CONFIGURE_ND_TEMPLATE)
 
+        # Need to define what setting is for SLAAC
+        if (not opts.get('dhcpv6_stateless', False) or
+                opts.get('dhcpv6_stateless', '') not in ('true', True)):
+            prefix += ' no-autoconfig'
 
-def nd_reconfigure(interface, prefix, opts):
-    LOG.info('FRR IPv6 ND reconfiguration (intf %s, prefix %s)', interface,
-             prefix)
-    nd_template = Template(CONFIGURE_ND_TEMPLATE)
+        # Parse dns servers from dhcp options.
+        dns_servers = []
+        if opts.get('dns_server'):
+            dns_servers = [
+                s.strip() for s in opts['dns_server'][1:-1].split(',')
+            ]
 
-    # Need to define what setting is for SLAAC
-    if (not opts.get('dhcpv6_stateless', False) or
-            opts.get('dhcpv6_stateless', '') not in ('true', True)):
-        prefix += ' no-autoconfig'
+        is_dhcpv6 = True  # Need a better way to define this one.
 
-    # Parse dns servers from dhcp options.
-    dns_servers = []
-    if opts.get('dns_server'):
-        dns_servers = [s.strip() for s in opts['dns_server'][1:-1].split(',')]
+        nd_config = nd_template.render(
+            intf=interface,
+            prefix=prefix,
+            dns_servers=dns_servers,
+            is_dhcpv6=is_dhcpv6,
+        )
 
-    is_dhcpv6 = True  # Need a better way to define this one.
+        self._run_vtysh_config_with_tempfile(nd_config)
 
-    nd_config = nd_template.render(
-        intf=interface,
-        prefix=prefix,
-        dns_servers=dns_servers,
-        is_dhcpv6=is_dhcpv6,
-    )
+    def vrf_leak(self, vrf, bgp_as, bgp_router_id=None,
+                 template=LEAK_VRF_TEMPLATE):
+        LOG.info("Add VRF leak for VRF %s on router bgp %s", vrf, bgp_as)
+        if not bgp_router_id:
+            bgp_router_id = self._get_router_id()
+            if not bgp_router_id:
+                LOG.error("Unknown router-id, needed for route leaking")
+                return
+
+        vrf_template = Template(template)
+        vrf_config = vrf_template.render(vrf_name=vrf, bgp_as=bgp_as,
+                                         redistribute=DEFAULT_REDISTRIBUTE,
+                                         bgp_router_id=bgp_router_id)
+        self._run_vtysh_config_with_tempfile(vrf_config)
+
+    def vrf_reconfigure(self, evpn_info, action):
+        LOG.info("FRR reconfiguration (action = %s) for evpn: %s",
+                 action, evpn_info)
+
+        # If we have more actions, we can define them in this list.
+        vrf_templates = {
+            'add-vrf': ADD_VRF_TEMPLATE,
+            'del-vrf': DEL_VRF_TEMPLATE,
+        }
+        if action not in vrf_templates:
+            LOG.error("Unknown FRR reconfiguration action: %s", action)
+            return
 
-    _run_vtysh_config_with_tempfile(nd_config)
+        # Set default opts, so all params are available for the templates
+        # Then update them with evpn_info
+        opts = dict(route_targets=[], route_distinguishers=[],
+                    export_targets=[], import_targets=[],
+                    local_ip=CONF.evpn_local_ip,
+                    redistribute=DEFAULT_REDISTRIBUTE,
+                    bgp_as=CONF.bgp_AS, vrf_name='', vni=0)
+        opts.update(evpn_info)
 
+        if not opts['vrf_name']:
+            opts['vrf_name'] = "{}{}".format(constants.OVN_EVPN_VRF_PREFIX,
+                                             evpn_info['vni'])
 
-def vrf_leak(vrf, bgp_as, bgp_router_id=None, template=LEAK_VRF_TEMPLATE):
-    LOG.info("Add VRF leak for VRF %s on router bgp %s", vrf, bgp_as)
-    if not bgp_router_id:
-        bgp_router_id = _get_router_id()
-        if not bgp_router_id:
-            LOG.error("Unknown router-id, needed for route leaking")
-            return
+        vrf_template = Template(vrf_templates.get(action))
+        vrf_config = vrf_template.render(**opts)
 
-    vrf_template = Template(template)
-    vrf_config = vrf_template.render(vrf_name=vrf, bgp_as=bgp_as,
-                                     redistribute=DEFAULT_REDISTRIBUTE,
-                                     bgp_router_id=bgp_router_id)
-    _run_vtysh_config_with_tempfile(vrf_config)
-
-
-def vrf_reconfigure(evpn_info, action):
-    LOG.info("FRR reconfiguration (action = %s) for evpn: %s",
-             action, evpn_info)
-
-    # If we have more actions, we can define them in this list.
-    vrf_templates = {
-        'add-vrf': ADD_VRF_TEMPLATE,
-        'del-vrf': DEL_VRF_TEMPLATE,
-    }
-    if action not in vrf_templates:
-        LOG.error("Unknown FRR reconfiguration action: %s", action)
-        return
-
-    # Set default opts, so all params are available for the templates
-    # Then update them with evpn_info
-    opts = dict(route_targets=[], route_distinguishers=[], export_targets=[],
-                import_targets=[], local_ip=CONF.evpn_local_ip,
-                redistribute=DEFAULT_REDISTRIBUTE,
-                bgp_as=CONF.bgp_AS, vrf_name='', vni=0)
-    opts.update(evpn_info)
-
-    if not opts['vrf_name']:
-        opts['vrf_name'] = "{}{}".format(constants.OVN_EVPN_VRF_PREFIX,
-                                         evpn_info['vni'])
-
-    vrf_template = Template(vrf_templates.get(action))
-    vrf_config = vrf_template.render(**opts)
-
-    _run_vtysh_config_with_tempfile(vrf_config)
+        self._run_vtysh_config_with_tempfile(vrf_config)
diff --git a/ovn_bgp_agent/drivers/openstack/utils/frr_k8s.py b/ovn_bgp_agent/drivers/openstack/utils/frr_k8s.py
new file mode 100644
index 0000000..c1eeb08
--- /dev/null
+++ b/ovn_bgp_agent/drivers/openstack/utils/frr_k8s.py
@@ -0,0 +1,327 @@
+# Copyright 2024 VEXXHOST, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from collections import defaultdict
+from kubernetes import client
+from kubernetes import config
+from oslo_config import cfg
+from oslo_log import log as logging
+from ovn_bgp_agent.drivers import frr_driver_api
+
+CONF = cfg.CONF
+
+LOG = logging.getLogger(__name__)
+
+
+class BGPSession:
+    def __init__(self, peer_address, source_address, my_asn, router_id,
+                 peer_asn, dynamic_asn=None, hold_time=None,
+                 keep_alive_time=None, connect_time=None, password=None,
+                 password_secret=None, current_node=None, bfd_profile=None,
+                 graceful_restart=False, ebgp_multi_hop=False, vrf_name=None,
+                 session_name="", disable_mp=False, to_advertise=None,
+                 to_receive=None):
+        self.peer_address = peer_address
+        self.source_address = source_address
+        self.my_asn = my_asn
+        self.router_id = router_id
+        self.peer_asn = peer_asn
+        self.dynamic_asn = dynamic_asn
+        self.hold_time = hold_time
+        self.keep_alive_time = keep_alive_time
+        self.connect_time = connect_time
+        self.password = password
+        self.password_secret = password_secret
+        self.current_node = current_node
+        self.bfd_profile = bfd_profile
+        self.graceful_restart = graceful_restart
+        self.ebgp_multi_hop = ebgp_multi_hop
+        self.vrf_name = vrf_name
+        self.session_name = session_name
+        self.disable_mp = disable_mp
+        self.to_advertise = to_advertise or []
+        self.to_receive = to_receive or []
+
+        self.validate_session()
+
+    def validate_session(self):
+        if not self.peer_address or not self.source_address:
+            raise ValueError(
+                "Peer and source addresses must be specified"
+            )
+        if self.password and self.password_secret:
+            raise ValueError(
+                "Cannot specify both password and password reference"
+            )
+
+
+class Advertisement:
+    def __init__(self, prefixes, communities=None, local_prefs=None):
+        self.prefixes = prefixes
+        self.communities = communities or []
+        self.local_prefs = local_prefs
+
+
+class FRRK8sDriver(frr_driver_api.FRRDriverBase):
+
+    def __init__(self):
+        # Load Kubernetes configuration
+        config.load_incluster_config()
+        self.namespace = CONF.frr_k8s.namespace
+        self.node_to_config = CONF.frr_k8s.node_to_config
+        self.prefixes = CONF.frr_k8s.prefixes
+        self.vrf_name = CONF.frr_k8s.vrf_name
+        self.sessions = []
+        session = BGPSession(
+            peer_address=CONF.frr_k8s.peer_address,
+            source_address=CONF.frr_k8s.source_address,
+            my_asn=CONF.frr_k8s.my_asn,
+            router_id=CONF.frr_k8s.router_id,
+            peer_asn=CONF.frr_k8s.peer_asn,
+            dynamic_asn=CONF.frr_k8s.dynamic_asn,
+            hold_time=CONF.frr_k8s.hold_time,
+            keep_alive_time=CONF.frr_k8s.keep_alive_time,
+            connect_time=CONF.frr_k8s.connect_time,
+            password=CONF.frr_k8s.password,
+            password_secret=CONF.frr_k8s.password_secret,
+            current_node=CONF.frr_k8s.node_to_config,
+            bfd_profile=CONF.frr_k8s.bfd_profile,
+            ebgp_multi_hop=CONF.frr_k8s.ebgp_multi_hop,
+            vrf_name=CONF.frr_k8s.vrf_name,
+            disable_mp=CONF.frr_k8s.disable_mp,
+            graceful_restart=CONF.frr_k8s.graceful_restart,
+            session_name="vrf_leak",
+        )
+        self.sessions.append(session)
+        self.bfd_profiles = []
+        if CONF.frr_k8s.bfd_profile:
+            self.bfd_profiles.append(CONF.frr_k8s.bfd_profile)
+        if CONF.frr_k8s.communities or CONF.frr_k8s.local_pref:
+            self.local_prefs = CONF.frr_k8s.local_pref
+            self.communities = CONF.frr_k8s.communities
+            self.adv = Advertisement(self.prefixes,
+                                     self.communities,
+                                     self.local_prefs)
+            self.sessions[0].to_advertise = [self.adv]
+        if CONF.frr_k8s.to_receive:
+            self.sessions.to_receive = CONF.frr_k8s.to_receive
+        self.api_instance = client.CustomObjectsApi()
+
+    def _create_frr_configuration(self):
+        new_config = {
+            "spec": {
+                "nodeSelector": {
+                    "matchLabels": {
+                        "kubernetes.io/hostname": self.node_to_config,
+                    }
+                },
+                "bgp": {
+                    "routers": [],
+                },
+                "raw": {
+                },
+            },
+        }
+
+        routers = {}
+
+        for session in self.sessions:
+            router_name = (
+                f"{session.router_id}-{session.my_asn}-{session.vrf_name}"
+            )
+            if router_name not in routers:
+                routers[router_name] = {
+                    "asn": session.my_asn,
+                    "id": session.router_id,
+                    "vrf": session.vrf_name,
+                    "neighbors": {},
+                    "prefixes": set()
+                }
+
+            neighbor_name = (
+                f"{session.peer_address}-{session.peer_asn}-"
+                f"{session.dynamic_asn}-{session.vrf_name}"
+            )
+            if neighbor_name not in routers[router_name]["neighbors"]:
+                host, port = session.peer_address.split(":")
+                neighbor = {
+                    "asn": session.peer_asn,
+                    "address": host,
+                    "port": int(port),
+                    "holdTime": session.hold_time or "180s",
+                    "keepaliveTime": session.keep_alive_time or "60s",
+                    "passwordSecret": session.password_secret or {},
+                    "toAdvertise": {
+                        "allowed": {},
+                    },
+                    "toReceive": {
+                        "allowed": {},
+                    },
+                }
+                if session.password:
+                    neighbor["password"] = session.password
+                if session.bfd_profile:
+                    neighbor["bfdProfile"] = session.bfd_profile
+                if session.ebgp_multi_hop:
+                    neighbor["ebgpMultiHop"] = session.ebgp_multi_hop
+                if session.graceful_restart:
+                    neighbor["enableGracefulRestart"] = (
+                        session.graceful_restart
+                    )
+                if session.disable_mp:
+                    neighbor["disableMP"] = session.disable_mp
+                if session.dynamic_asn:
+                    neighbor["dynamicASN"] = session.dynamic_asn
+                if session.connect_time:
+                    neighbor["connectTime"] = session.connect_time
+                routers[router_name]["neighbors"][neighbor_name] = neighbor
+
+            # Process advertised prefixes
+            prefixes_with_community = defaultdict(list)
+            prefixes_with_local_pref = defaultdict(list)
+            for adv in session.to_advertise:
+                prefixes = adv.prefixes
+                for prefix in prefixes:
+                    routers[router_name]["prefixes"].add(prefix)
+                    allowed_prefixes = routers[router_name][
+                        "neighbors"][neighbor_name]["toAdvertise"]["allowed"]
+                    if not allowed_prefixes.get("prefixes", []):
+                        allowed_prefixes["prefixes"] = []
+                    allowed_prefixes["prefixes"].append(prefix)
+
+                    for community in adv.communities:
+                        prefixes_with_community[community].append(prefix)
+                    if adv.local_prefs:
+                        for local_pref in adv.local_prefs:
+                            prefixes_with_local_pref[local_pref].append(prefix)
+
+                routers[router_name]["neighbors"][neighbor_name][
+                    "toAdvertise"
+                ]["withCommunity"] = [
+                    {"community": community, "prefixes": sorted(prefixes)}
+                    for community, prefixes in prefixes_with_community.items()
+                ]
+                routers[router_name]["neighbors"][neighbor_name][
+                    "toAdvertise"
+                ]["withLocalPref"] = [
+                    {
+                        "localPref": int(local_pref),
+                        "prefixes": sorted(prefixes)
+                    }
+                    for local_pref, prefixes in
+                    prefixes_with_local_pref.items()
+                ]
+
+        # Add routers to configuration
+        for router_name, router in routers.items():
+            new_config["spec"]["bgp"]["routers"].append({
+                "asn": router["asn"],
+                "id": router["id"],
+                "vrf": router["vrf"],
+                "neighbors": list(router["neighbors"].values()),
+                "prefixes": sorted(router["prefixes"]),
+            })
+
+        # Add BFD profiles
+        for bfd in self.bfd_profiles:
+            new_config["spec"]["bgp"]["bfdProfiles"].append({
+                "name": bfd.name,
+                "receiveInterval": bfd.receive_interval,
+                "transmitInterval": bfd.transmit_interval,
+                "detectMultiplier": bfd.detect_multiplier,
+                "echoInterval": bfd.echo_interval,
+                "minimumTTL": bfd.minimum_ttl,
+                "echoMode": bfd.echo_mode,
+                "passiveMode": bfd.passive_mode,
+            })
+
+            # Sort BFD profiles by name
+            new_config["spec"]["bgp"]["bfdProfiles"].sort(
+                key=lambda x: x["name"]
+            )
+
+        body = {
+            "apiVersion": "frrk8s.metallb.io/v1beta1",
+            "kind": "FRRConfiguration",
+            "metadata": {
+                "name": self.vrf_name + '-' + self.node_to_config,
+                "namespace": self.namespace
+            },
+            "spec": new_config["spec"],
+        }
+        try:
+            self.api_instance.create_namespaced_custom_object(
+                group="frrk8s.metallb.io",
+                version="v1beta1",
+                namespace=self.namespace,
+                plural="frrconfigurations",
+                body=body,
+            )
+            LOG.info(
+                f"FRRConfiguration {self.vrf_name}-"
+                f"{self.node_to_config} created successfully."
+            )
+        except client.exceptions.ApiException as e:
+            LOG.error(
+                f"Failed to create FRRConfiguration "
+                f"{self.vrf_name}-{self.node_to_config}: {e}"
+            )
+            raise
+
+    def nd_reconfigure(self, interface, prefix, opts):
+        LOG.info(
+            'FRR IPv6 ND reconfiguration (intf %s, prefix %s)',
+            interface,
+            prefix
+        )
+
+        self._create_frr_configuration()
+
+    def vrf_leak(self, vrf, bgp_as, bgp_router_id=None,
+                 template=None):
+        LOG.info("Add VRF leak for VRF %s on router bgp %s", vrf, bgp_as)
+        try:
+            frrconfig = self.api_instance.get_namespaced_custom_object(
+                group="frrk8s.metallb.io",
+                version="v1beta1",
+                namespace=self.namespace,
+                plural="frrconfigurations",
+                name=self.vrf_name + '-' + self.node_to_config
+            )
+            LOG.info(
+                f"FRRConfiguration exists in namespace "
+                f"'{self.namespace}': {frrconfig}"
+            )
+        except client.exceptions.ApiException as e:
+            if e.status == 404:
+                self._create_frr_configuration()
+            else:
+                LOG.error(
+                    "Exception when retrieving FRRConfiguration."
+                )
+
+    def vrf_reconfigure(self, evpn_info, action):
+        LOG.info(
+            "FRR reconfiguration (action = %s) for evpn: %s",
+            action,
+            evpn_info
+        )
+
+        # If we have more actions, we can define them in this list.
+        vrf_templates = ['add-vrf', 'del-vrf']
+        if action not in vrf_templates:
+            LOG.error("Unknown FRR reconfiguration action: %s", action)
+            return
+
+        self._create_frr_configuration()
diff --git a/ovn_bgp_agent/tests/unit/drivers/openstack/test_nb_ovn_bgp_driver.py b/ovn_bgp_agent/tests/unit/drivers/openstack/test_nb_ovn_bgp_driver.py
index 6a56e13..dfc2dac 100644
--- a/ovn_bgp_agent/tests/unit/drivers/openstack/test_nb_ovn_bgp_driver.py
+++ b/ovn_bgp_agent/tests/unit/drivers/openstack/test_nb_ovn_bgp_driver.py
@@ -76,7 +76,7 @@ class TestNBOVNBGPDriver(test_base.TestCase):
         self.conf_ovsdb_connection = 'tcp:127.0.0.1:6642'
 
     @mock.patch.object(linux_net, 'ensure_vrf')
-    @mock.patch.object(frr, 'vrf_leak')
+    @mock.patch.object(frr.FRRDriver, 'vrf_leak')
     @mock.patch.object(linux_net, 'ensure_ovn_device')
     @mock.patch.object(linux_net, 'delete_routes_from_table')
     def test_start(self, mock_delete_routes_from_table,
@@ -110,7 +110,7 @@ class TestNBOVNBGPDriver(test_base.TestCase):
         self.mock_nbdb().start.assert_called_once_with()
 
     @mock.patch.object(linux_net, 'ensure_ovn_device')
-    @mock.patch.object(frr, 'vrf_leak')
+    @mock.patch.object(frr.FRRDriver, 'vrf_leak')
     @mock.patch.object(linux_net, 'ensure_vrf')
     def test_frr_sync(self, mock_ensure_vrf, mock_vrf_leak,
                       mock_ensure_ovn_dev):
diff --git a/ovn_bgp_agent/tests/unit/drivers/openstack/test_ovn_bgp_driver.py b/ovn_bgp_agent/tests/unit/drivers/openstack/test_ovn_bgp_driver.py
index dbf3876..3d2e86f 100644
--- a/ovn_bgp_agent/tests/unit/drivers/openstack/test_ovn_bgp_driver.py
+++ b/ovn_bgp_agent/tests/unit/drivers/openstack/test_ovn_bgp_driver.py
@@ -75,7 +75,7 @@ class TestOVNBGPDriver(test_base.TestCase):
 
     @mock.patch.object(linux_net, 'ensure_ovn_device')
     @mock.patch.object(linux_net, 'ensure_vrf')
-    @mock.patch.object(frr, 'vrf_leak')
+    @mock.patch.object(frr.FRRDriver, 'vrf_leak')
     def test_start(self, mock_vrf, *args):
         self.bgp_driver.start()
 
@@ -88,7 +88,7 @@ class TestOVNBGPDriver(test_base.TestCase):
         self.mock_sbdb().start.assert_called_once_with()
 
     @mock.patch.object(linux_net, 'ensure_ovn_device')
-    @mock.patch.object(frr, 'vrf_leak')
+    @mock.patch.object(frr.FRRDriver, 'vrf_leak')
     @mock.patch.object(linux_net, 'ensure_vrf')
     def test_frr_sync(self, mock_ensure_vrf, mock_vrf_leak,
                       mock_ensure_ovn_dev):
diff --git a/ovn_bgp_agent/tests/unit/drivers/openstack/test_ovn_evpn_driver.py b/ovn_bgp_agent/tests/unit/drivers/openstack/test_ovn_evpn_driver.py
index 0815577..204b164 100644
--- a/ovn_bgp_agent/tests/unit/drivers/openstack/test_ovn_evpn_driver.py
+++ b/ovn_bgp_agent/tests/unit/drivers/openstack/test_ovn_evpn_driver.py
@@ -185,7 +185,7 @@ class TestOVNEVPNDriver(test_base.TestCase):
         self.assertEqual((None, None), ret)
 
     @mock.patch.object(linux_net, 'add_ip_nei')
-    @mock.patch.object(frr, 'vrf_reconfigure')
+    @mock.patch.object(frr.FRRDriver, 'vrf_reconfigure')
     def _test_expose_ip(
             self, mock_vrf_reconfigure, mock_add_ip_nei, cr_lrp=False):
         mock_get_bridge = mock.patch.object(
@@ -246,7 +246,7 @@ class TestOVNEVPNDriver(test_base.TestCase):
         self._test_expose_ip(cr_lrp=True)
 
     @mock.patch.object(ovs, 'remove_evpn_router_ovs_flows')
-    @mock.patch.object(frr, 'vrf_reconfigure')
+    @mock.patch.object(frr.FRRDriver, 'vrf_reconfigure')
     def _test_withdraw_ip(
             self, mock_vrf_reconfigure, mock_remove_evpn_flows, cr_lrp=True,
             ret_vlan_tag=True):
diff --git a/ovn_bgp_agent/tests/unit/drivers/openstack/test_ovn_stretched_l2_bgp_driver.py b/ovn_bgp_agent/tests/unit/drivers/openstack/test_ovn_stretched_l2_bgp_driver.py
index 896d4ac..a429c69 100644
--- a/ovn_bgp_agent/tests/unit/drivers/openstack/test_ovn_stretched_l2_bgp_driver.py
+++ b/ovn_bgp_agent/tests/unit/drivers/openstack/test_ovn_stretched_l2_bgp_driver.py
@@ -138,13 +138,13 @@ class TestOVNBGPStretchedL2Driver(test_base.TestCase):
     @mock.patch.object(linux_net, "ensure_vrf")
     @mock.patch.object(linux_net, "ensure_ovn_device")
     @mock.patch.object(linux_net, "delete_routes_from_table")
-    @mock.patch.object(frr, "vrf_leak")
+    @mock.patch.object(frr.FRRDriver, "vrf_leak")
     def test_start(self, mock_vrf, mock_delete_routes, mock_ensure_ovn_device,
                    *args):
         CONF.set_override("clear_vrf_routes_on_startup", True)
 
         mock_redistribute = mock.patch.object(
-            frr, "set_default_redistribute"
+            frr.FRRDriver, "set_default_redistribute"
         ).start()
 
         self.bgp_driver.start()
@@ -168,13 +168,13 @@ class TestOVNBGPStretchedL2Driver(test_base.TestCase):
     @mock.patch.object(linux_net, "ensure_vrf")
     @mock.patch.object(linux_net, "ensure_ovn_device")
     @mock.patch.object(linux_net, "delete_routes_from_table")
-    @mock.patch.object(frr, "vrf_leak")
+    @mock.patch.object(frr.FRRDriver, "vrf_leak")
     def test_start_clear_routes(
         self, mock_vrf, mock_delete_routes, mock_ensure_ovn_device, *args):
         CONF.set_override("clear_vrf_routes_on_startup", False)
 
         mock_redistribute = mock.patch.object(
-            frr, "set_default_redistribute"
+            frr.FRRDriver, "set_default_redistribute"
         ).start()
 
         self.bgp_driver.start()
diff --git a/ovn_bgp_agent/tests/unit/drivers/openstack/utils/test_bgp.py b/ovn_bgp_agent/tests/unit/drivers/openstack/utils/test_bgp.py
index ee3fb79..6fbc2e4 100644
--- a/ovn_bgp_agent/tests/unit/drivers/openstack/utils/test_bgp.py
+++ b/ovn_bgp_agent/tests/unit/drivers/openstack/utils/test_bgp.py
@@ -17,6 +17,7 @@ from oslo_config import cfg
 from unittest import mock
 
 from ovn_bgp_agent import constants
+from ovn_bgp_agent.drivers import frr_driver_api
 from ovn_bgp_agent.drivers.openstack.utils import bgp as bgp_utils
 from ovn_bgp_agent.tests import base as test_base
 
@@ -90,19 +91,23 @@ class TestEVPN(test_base.TestCase):
     def test_withdraw_ips_l2vni(self):
         self._test_withdraw_ips('l2vni')
 
-    def _test_ensure_base_bgp_configuration(self, exposing_method):
+    @mock.patch.object(frr_driver_api.FRRDriverBase, "get_instance")
+    def _test_ensure_base_bgp_configuration(self, exposing_method,
+                                            mock_get_instance):
         self._set_exposing_method(exposing_method)
 
+        mock_frr_driver = mock.Mock()
+        mock_get_instance.return_value = mock_frr_driver
         bgp_utils.ensure_base_bgp_configuration()
 
         if exposing_method not in [constants.EXPOSE_METHOD_UNDERLAY,
                                    constants.EXPOSE_METHOD_DYNAMIC,
                                    constants.EXPOSE_METHOD_OVN]:
-            self.mock_frr.vrf_leak.assert_not_called()
+            mock_frr_driver.vrf_leak.assert_not_called()
             self.mock_linux_net.ensure_vrf.assert_not_called()
             self.mock_linux_net.ensure_ovn_device.assert_not_called()
         else:
-            self.mock_frr.vrf_leak.assert_called_once()
+            mock_frr_driver.vrf_leak.assert_called_once()
             self.mock_linux_net.ensure_vrf.assert_called_once()
             self.mock_linux_net.ensure_ovn_device.assert_called_once()
 
diff --git a/ovn_bgp_agent/tests/unit/drivers/openstack/utils/test_frr.py b/ovn_bgp_agent/tests/unit/drivers/openstack/utils/test_frr.py
index ef1913b..4ec6ef8 100644
--- a/ovn_bgp_agent/tests/unit/drivers/openstack/utils/test_frr.py
+++ b/ovn_bgp_agent/tests/unit/drivers/openstack/utils/test_frr.py
@@ -26,20 +26,21 @@ class TestFrr(test_base.TestCase):
     def setUp(self):
         super(TestFrr, self).setUp()
         self.mock_vtysh = mock.patch('ovn_bgp_agent.privileged.vtysh').start()
+        self.frr_driver = frr_utils.FRRDriver()
 
     def test__get_router_id(self):
         router_id = 'fake-router'
         self.mock_vtysh.run_vtysh_command.return_value = (
             '{"ipv4Unicast": {"routerId": "%s"}}' % router_id)
-        ret = frr_utils._get_router_id()
+        ret = self.frr_driver._get_router_id()
         self.assertEqual(router_id, ret)
 
     def test__get_router_id_no_ipv4_settings(self):
         self.mock_vtysh.run_vtysh_command.return_value = '{}'
-        ret = frr_utils._get_router_id()
+        ret = self.frr_driver._get_router_id()
         self.assertIsNone(ret)
 
-    @mock.patch.object(frr_utils, '_get_router_id')
+    @mock.patch.object(frr_utils.FRRDriver, '_get_router_id')
     @mock.patch.object(tempfile, 'NamedTemporaryFile')
     def test_vrf_leak(self, mock_tf, mock_gri):
         vrf = 'fake-vrf'
@@ -47,7 +48,7 @@ class TestFrr(test_base.TestCase):
         router_id = 'fake-router-id'
         mock_gri.return_value = router_id
 
-        frr_utils.vrf_leak(vrf, bgp_as)
+        self.frr_driver.vrf_leak(vrf, bgp_as)
 
         write_arg = mock_tf.return_value.write.call_args_list[0][0][0]
         self.assertIn(vrf, write_arg)
@@ -55,11 +56,11 @@ class TestFrr(test_base.TestCase):
         # Assert the file was closed
         mock_tf.return_value.close.assert_called_once_with()
 
-    @mock.patch.object(frr_utils, '_get_router_id')
+    @mock.patch.object(frr_utils.FRRDriver, '_get_router_id')
     @mock.patch.object(tempfile, 'NamedTemporaryFile')
     def test_vrf_leak_no_router_id(self, mock_tf, mock_gri):
         mock_gri.return_value = None
-        frr_utils.vrf_leak('fake-vrf', 'fake-bgp-as')
+        self.frr_driver.vrf_leak('fake-vrf', 'fake-bgp-as')
         # Assert no file was created
         self.assertFalse(mock_tf.called)
 
@@ -68,7 +69,7 @@ class TestFrr(test_base.TestCase):
         action = 'add-vrf' if add_vrf else 'del-vrf'
         evpn_info = {'vni': '1001', 'bgp_as': 'fake-bgp-as'}
 
-        frr_utils.vrf_reconfigure(evpn_info, action)
+        self.frr_driver.vrf_reconfigure(evpn_info, action)
 
         vrf_name = "{}{}".format(constants.OVN_EVPN_VRF_PREFIX,
                                  evpn_info['vni'])
@@ -93,7 +94,9 @@ class TestFrr(test_base.TestCase):
         self._test_vrf_reconfigure(add_vrf=False)
 
     def test_vrf_reconfigure_unknown_action(self):
-        frr_utils.vrf_reconfigure({'fake': 'evpn-info'}, 'non-existing-action')
+        self.frr_driver.vrf_reconfigure(
+            {'fake': 'evpn-info'}, 'non-existing-action'
+        )
         # Assert run_vtysh_command() wasn't called
         self.assertFalse(self.mock_vtysh.run_vtysh_config.called)
 
@@ -106,7 +109,7 @@ class TestFrr(test_base.TestCase):
             'dns_server': '{2001:4860:4860::8888, 2001:4860:4860::8844}',
         }
 
-        frr_utils.nd_reconfigure(interface, prefix, opts)
+        self.frr_driver.nd_reconfigure(interface, prefix, opts)
 
         write_arg = mock_tf.return_value.write.call_args_list[0][0][0]
 
diff --git a/ovn_bgp_agent/tests/unit/drivers/openstack/utils/test_frr_k8s.py b/ovn_bgp_agent/tests/unit/drivers/openstack/utils/test_frr_k8s.py
new file mode 100644
index 0000000..0326687
--- /dev/null
+++ b/ovn_bgp_agent/tests/unit/drivers/openstack/utils/test_frr_k8s.py
@@ -0,0 +1,140 @@
+# Copyright 2024 VEXXHOST, Inc.
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+import json
+import os
+
+from unittest import mock
+
+from oslo_config import cfg
+
+from kubernetes import client
+from kubernetes import config
+from ovn_bgp_agent.drivers.openstack.utils import frr_k8s
+from ovn_bgp_agent.tests import base as test_base
+
+
+CONF = cfg.CONF
+
+
+class TestFrrK8s(test_base.TestCase):
+
+    @mock.patch.object(config, "load_incluster_config")
+    @mock.patch.object(client, "CustomObjectsApi")
+    def setUp(self, mock_custom_objects_api, mock_load_incluster_config):
+        super(TestFrrK8s, self).setUp()
+        self.mock_api = mock.MagicMock()
+        mock_custom_objects_api.return_value = self.mock_api
+
+    def load_golden_file(self, filename):
+        data = {}
+        file_path = os.path.join(os.path.dirname(__file__), filename)
+        if os.path.isfile(file_path):
+            with open(file_path, 'r') as f:
+                file_content = f.read().strip()
+                if file_content:
+                    data = json.loads(file_content)
+        return data
+
+    @mock.patch.object(config, "load_incluster_config")
+    @mock.patch.object(client, "CustomObjectsApi")
+    def test_SingleVRFIBGP(self, mock_custom_objects_api,
+                           mock_load_incluster_config):
+
+        CONF.set_override("node_to_config", "testnodename", "frr_k8s")
+        CONF.set_override("peer_address", "10.2.2.254:179", "frr_k8s")
+        CONF.set_override("source_address", "10.1.1.254", "frr_k8s")
+        CONF.set_override("my_asn", 100, "frr_k8s")
+        CONF.set_override("router_id", "10.1.1.254", "frr_k8s")
+        CONF.set_override("peer_asn", 100, "frr_k8s")
+        CONF.set_override("hold_time", "1s", "frr_k8s")
+        CONF.set_override("keep_alive_time", "1s", "frr_k8s")
+        CONF.set_override("password", "password", "frr_k8s")
+        CONF.set_override("ebgp_multi_hop", False, "frr_k8s")
+        CONF.set_override("vrf_name", "fake-vrf", "frr_k8s")
+
+        CONF.clear_override("prefixes", "frr_k8s")
+        CONF.clear_override("communities", "frr_k8s")
+        CONF.clear_override("local_pref", "frr_k8s")
+
+        mock_api = mock.MagicMock()
+        mock_custom_objects_api.return_value = mock_api
+        frr_driver = frr_k8s.FRRK8sDriver()
+        session = frr_driver.sessions[0]
+        session.session_name = "TestSingleVRFIBGP"
+
+        frr_driver._create_frr_configuration()
+
+        expected_data = self.load_golden_file(
+            'testdata/' + session.session_name + '.golden'
+        )
+
+        mock_api.create_namespaced_custom_object.assert_called_once_with(
+            group="frrk8s.metallb.io",
+            version="v1beta1",
+            namespace=CONF.frr_k8s.namespace,
+            plural="frrconfigurations",
+            body={
+                "apiVersion": "frrk8s.metallb.io/v1beta1",
+                "kind": "FRRConfiguration",
+                "metadata": expected_data['metadata'],
+                "spec": expected_data['spec'],
+            },
+        )
+
+    @mock.patch.object(config, "load_incluster_config")
+    @mock.patch.object(client, "CustomObjectsApi")
+    def test_SingleAdvertisementVRF(self, mock_custom_objects_api,
+                                    mock_load_incluster_config):
+
+        CONF.set_override("node_to_config", "testnodename", "frr_k8s")
+        CONF.set_override("peer_address", "10.2.2.254:179", "frr_k8s")
+        CONF.set_override("source_address", "10.1.1.254", "frr_k8s")
+        CONF.set_override("my_asn", 100, "frr_k8s")
+        CONF.set_override("router_id", "10.1.1.254", "frr_k8s")
+        CONF.set_override("peer_asn", 200, "frr_k8s")
+        CONF.set_override("hold_time", "1s", "frr_k8s")
+        CONF.set_override("keep_alive_time", "1s", "frr_k8s")
+        CONF.set_override("password", "password", "frr_k8s")
+        CONF.set_override("ebgp_multi_hop", False, "frr_k8s")
+        CONF.set_override("vrf_name", "fake-vrf", "frr_k8s")
+
+        CONF.set_override("prefixes", ["172.16.1.10/24"], "frr_k8s")
+        CONF.set_override("communities", ["1111:2222", "3333:4444"], "frr_k8s")
+        CONF.set_override("local_pref", [300], "frr_k8s")
+
+        mock_api = mock.MagicMock()
+        mock_custom_objects_api.return_value = mock_api
+        frr_driver = frr_k8s.FRRK8sDriver()
+        session = frr_driver.sessions[0]
+        session.session_name = "TestSingleAdvertisementVRF"
+
+        frr_driver._create_frr_configuration()
+
+        expected_data = self.load_golden_file(
+            'testdata/' + session.session_name + '.golden'
+        )
+        mock_api.create_namespaced_custom_object.assert_called_once_with(
+            group="frrk8s.metallb.io",
+            version="v1beta1",
+            namespace=CONF.frr_k8s.namespace,
+            plural="frrconfigurations",
+            body={
+                "apiVersion": "frrk8s.metallb.io/v1beta1",
+                "kind": "FRRConfiguration",
+                "metadata": expected_data['metadata'],
+                "spec": expected_data['spec'],
+            },
+        )
diff --git a/ovn_bgp_agent/tests/unit/drivers/openstack/utils/testdata/TestSingleAdvertisementVRF.golden b/ovn_bgp_agent/tests/unit/drivers/openstack/utils/testdata/TestSingleAdvertisementVRF.golden
new file mode 100644
index 0000000..b051d71
--- /dev/null
+++ b/ovn_bgp_agent/tests/unit/drivers/openstack/utils/testdata/TestSingleAdvertisementVRF.golden
@@ -0,0 +1,70 @@
+{
+    "metadata": {
+        "name": "fake-vrf-testnodename",
+        "namespace": "frr-k8s-system"
+    },
+    "spec": {
+        "bgp": {
+            "routers": [
+                {
+                    "asn": 100,
+                    "id": "10.1.1.254",
+                    "vrf": "fake-vrf",
+                    "neighbors": [
+                        {
+                            "asn": 200,
+                            "address": "10.2.2.254",
+                            "port": 179,
+                            "password": "password",
+                            "passwordSecret": {},
+                            "holdTime": "1s",
+                            "keepaliveTime": "1s",
+                            "toAdvertise": {
+                                "allowed": {
+                                    "prefixes": [
+                                        "172.16.1.10/24"
+                                    ]
+                                },
+                                "withLocalPref": [
+                                    {
+                                        "prefixes": [
+                                            "172.16.1.10/24"
+                                        ],
+                                        "localPref": 300
+                                    }
+                                ],
+                                "withCommunity": [
+                                    {
+                                        "prefixes": [
+                                            "172.16.1.10/24"
+                                        ],
+                                        "community": "1111:2222"
+                                    },
+                                    {
+                                        "prefixes": [
+                                            "172.16.1.10/24"
+                                        ],
+                                        "community": "3333:4444"
+                                    }
+                                ]
+                            },
+                            "toReceive": {
+                                "allowed": {}
+                            }
+                        }
+                    ],
+                    "prefixes": [
+                        "172.16.1.10/24"
+                    ]
+                }
+            ]
+        },
+        "raw": {},
+        "nodeSelector": {
+            "matchLabels": {
+                "kubernetes.io/hostname": "testnodename"
+            }
+        }
+    },
+    "status": {}
+}
diff --git a/ovn_bgp_agent/tests/unit/drivers/openstack/utils/testdata/TestSingleVRFIBGP.golden b/ovn_bgp_agent/tests/unit/drivers/openstack/utils/testdata/TestSingleVRFIBGP.golden
new file mode 100644
index 0000000..bbbde4a
--- /dev/null
+++ b/ovn_bgp_agent/tests/unit/drivers/openstack/utils/testdata/TestSingleVRFIBGP.golden
@@ -0,0 +1,43 @@
+{
+    "metadata": {
+        "name": "fake-vrf-testnodename",
+        "namespace": "frr-k8s-system"
+    },
+    "spec": {
+        "bgp": {
+            "routers": [
+                {
+                    "asn": 100,
+                    "id": "10.1.1.254",
+                    "vrf": "fake-vrf",
+                    "neighbors": [
+                        {
+                            "asn": 100,
+                            "address": "10.2.2.254",
+                            "port": 179,
+                            "password": "password",
+                            "passwordSecret": {},
+                            "holdTime": "1s",
+                            "keepaliveTime": "1s",
+                            "toAdvertise": {
+                                "allowed": {}
+                            },
+                            "toReceive": {
+                                "allowed": {}
+                            }
+                        }
+                    ],
+                    "prefixes": [
+                    ]
+                }
+            ]
+        },
+        "raw": {},
+        "nodeSelector": {
+            "matchLabels": {
+                "kubernetes.io/hostname": "testnodename"
+            }
+        }
+    },
+    "status": {}
+}
diff --git a/setup.cfg b/setup.cfg
index c4ea0af..df46f0e 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -39,6 +39,12 @@ ovn_bgp_agent.drivers =
     nb_ovn_bgp_driver = ovn_bgp_agent.drivers.openstack.nb_ovn_bgp_driver:NBOVNBGPDriver
     ovn_evpn_driver = ovn_bgp_agent.drivers.openstack.ovn_evpn_driver:OVNEVPNDriver
     ovn_stretched_l2_bgp_driver = ovn_bgp_agent.drivers.openstack.ovn_stretched_l2_bgp_driver:OVNBGPStretchedL2Driver
+    frr = ovn_bgp_agent.drivers.openstack.utils.frr:FRRDriver
+    frr_k8s = ovn_bgp_agent.drivers.openstack.utils.frr_k8s:FRRK8sDriver
 
 oslo.config.opts =
     ovnbgpagent = ovn_bgp_agent.config:list_opts
+
+[extras]
+frr-k8s =
+    kubernetes>=24.2.0
diff --git a/test-requirements.txt b/test-requirements.txt
index 8e2cc74..ef0486b 100644
--- a/test-requirements.txt
+++ b/test-requirements.txt
@@ -11,3 +11,4 @@ oslotest>=1.10.0 # Apache-2.0
 pyroute2>=0.6.4;sys_platform!='win32' # Apache-2.0 (+ dual licensed GPL2)
 stestr>=1.0.0 # Apache-2.0
 testtools>=1.4.0 # MIT
+kubernetes>=24.2.0 # Apache-2.0
